<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JK Playground</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #eea005;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }

        #animation-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .circle {
            position: absolute;
            border-radius: 50%;
            opacity: 0.85;
        }

        .social-button { /* Changed class name */
            position: absolute;
            border-radius: 5px;
            cursor: pointer;
            z-index: 11;
        }

        .social-button img {
            width: 100%;
            height: 100%;
            display: block;
        }

        #control-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
            background-color: #00ffff;
            color: #28241c;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            font-family: sans-serif;
        }

        #control-button:hover {
          opacity: 0.8;
        }
    </style>
</head>
<body>
    <button id="control-button">Stop Animation</button>
    <div id="animation-container"></div>

    <script>
        const animationContainer = document.getElementById('animation-container');
        const controlButton = document.getElementById('control-button');

        // Constants
        const NUM_CIRCLES = 20;
        const ANIMATION_SPEED = 0.2;
        const MOUSE_INFLUENCE_RADIUS = 100;
        const REACTIVE_PERCENTAGE = 0.1;
        const REACTIVE_DURATION = 2000;
        const REACTIVE_SPEED_MULTIPLIER = 0.3;
        const REACTIVE_SPEED_RANDOMNESS = 0.5;
        const SPEED_RANDOMNESS_FACTOR = 2;
        const SOCIAL_BUTTON_SIZE = 100; // Doubled size
        const MIN_SIZE_PERCENTAGE = 0.05;
        const MAX_SIZE_PERCENTAGE = 0.15;
        const ABSOLUTE_MIN_SIZE = 20;
        const RESIZE_DEBOUNCE_TIME = 250;
        const INFLUENCE_FACTOR = 0.5;
        const OVERLAP_SEPARATION_FACTOR = 0.5;
        const GRID_CELL_SIZE = 150; // Adjusted for larger buttons
        const BUTTON_SPEED = 1; // Medium speed for buttons

        let mouseX = -MOUSE_INFLUENCE_RADIUS * 2;
        let mouseY = -MOUSE_INFLUENCE_RADIUS * 2;
        let circles = [];
        let animationRunning = true;
        let animationFrameId = null;
        let intervalId = null;
        let linkedinButton = null;
        let githubButton = null; // Added GitHub button
        let resizeTimeout;
        let grid = {};

        // --- Circle Class ---
        class Circle {
            constructor(x, y, size, moveXSpeed, moveYSpeed, hue) {
                this.x = x;  // vw
                this.y = y;  // vh
                this.size = size; // px
                this.moveXSpeed = moveXSpeed;
                this.moveYSpeed = moveYSpeed;
                this.hue = hue;
                this.element = document.createElement('div');
                this.element.classList.add('circle');
                this.element.style.backgroundColor = `hsl(${this.hue}, 100%, 50%)`;
                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;
                this.isReactive = false;
                this.reactiveUntil = 0;
                this.gridX = 0;
                this.gridY = 0;

                this.updatePosition();
                animationContainer.appendChild(this.element);
            }

            updatePosition() {
                this.element.style.left = `${this.x}vw`;
                this.element.style.top = `${this.y}vh`;
            }

            update(mouseX, mouseY) {
                this.handleCollisions();
                this.handleMouseInfluence(mouseX, mouseY);
                this.handleBoundaryCollisions();
                this.updatePosition();
                this.updateGridPosition();
            }

             updateGridPosition() {
              this.gridX = Math.floor((this.x / 100 * window.innerWidth) / GRID_CELL_SIZE);
              this.gridY = Math.floor((this.y / 100 * window.innerHeight) / GRID_CELL_SIZE);
            }

            handleCollisions() {
                const neighbors = getNeighbors(this);

                for (const other of neighbors) { //other can be Circle, or button
                    if (other === this) continue;

                    let otherLeft = other.x;
                    let otherTop = other.y;
                    const otherSize = other.size;

                    const currentLeftPx = this.x / 100 * window.innerWidth;
                    const currentTopPx = this.y / 100 * window.innerHeight;
                    const otherLeftPx = otherLeft / 100 * window.innerWidth;
                    const otherTopPx = otherTop / 100 * window.innerHeight;

                    const dx = otherLeftPx - currentLeftPx;
                    const dy = otherTopPx - currentTopPx;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = (this.size / 2) + (otherSize / 2);

                    if (distance < minDistance) {
                        const nx = dx / distance;
                        const ny = dy / distance;

                        // Check if the other object is a button
                        if (other instanceof SocialButton) {
                            // Only update the circle's velocity and position
                            const overlap = minDistance - distance;
                            this.x -= (nx * overlap) / window.innerWidth * 100;
                            this.y -= (ny * overlap) / window.innerHeight * 100;
                             // Reflect the circle's velocity
                            const dotProduct = this.moveXSpeed * nx + this.moveYSpeed * ny;
                            this.moveXSpeed -= 2 * dotProduct * nx;
                            this.moveYSpeed -= 2 * dotProduct * ny;

                            this.handleBoundaryCollisions(); // Ensure the circle stays within bounds
                        } else {
                            // Circle-Circle collision (existing logic)
                            const relativeVelocityX = this.moveXSpeed - other.moveXSpeed;
                            const relativeVelocityY = this.moveYSpeed - other.moveYSpeed;
                            const dotProduct = relativeVelocityX * nx + relativeVelocityY * ny;

                            if (dotProduct < 0) {
                                const impulse = (2 * dotProduct) / (1 + 1);
                                this.moveXSpeed -= impulse * nx;
                                this.moveYSpeed -= impulse * ny;
                                other.moveXSpeed += impulse * nx;
                                other.moveYSpeed += impulse * ny;
                            }

                            const overlap = minDistance - distance;
                            const separationX = nx * overlap * OVERLAP_SEPARATION_FACTOR;
                            const separationY = ny * overlap * OVERLAP_SEPARATION_FACTOR;

                            this.x -= (separationX / window.innerWidth * 100);
                            this.y -= (separationY / window.innerHeight * 100);
                            other.x += (separationX / window.innerWidth * 100);
                            other.y += (separationY / window.innerHeight * 100);

                            other.handleBoundaryCollisions();

                        }
                    }
                }
            }



            handleMouseInfluence(mouseX, mouseY) {
              if (this.isReactive && Date.now() < this.reactiveUntil) {
                    const currentLeft = this.x;
                    const currentTop = this.y;

                    const dx = (mouseX / window.innerWidth * 100) - currentLeft;
                    const dy = (mouseY / window.innerHeight * 100) - currentTop;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < MOUSE_INFLUENCE_RADIUS) {
                        const influence = (MOUSE_INFLUENCE_RADIUS - distance) / MOUSE_INFLUENCE_RADIUS;
                        this.moveXSpeed += (dx / distance) * influence * INFLUENCE_FACTOR * REACTIVE_SPEED_MULTIPLIER * (1 + random(-REACTIVE_SPEED_RANDOMNESS, REACTIVE_SPEED_RANDOMNESS));
                        this.moveYSpeed += (dy / distance) * influence * INFLUENCE_FACTOR * REACTIVE_SPEED_MULTIPLIER * (1 + random(-REACTIVE_SPEED_RANDOMNESS, REACTIVE_SPEED_RANDOMNESS));
                    }
                }

                const speedLimit = ANIMATION_SPEED * (this.isReactive ? 5 * REACTIVE_SPEED_MULTIPLIER : 5);
                this.moveXSpeed = Math.max(-speedLimit, Math.min(speedLimit, this.moveXSpeed));
                this.moveYSpeed = Math.max(-speedLimit, Math.min(speedLimit, this.moveYSpeed));

            }

            handleBoundaryCollisions() {
                if (this.x < 0 || this.x > 100 - (this.size / window.innerWidth * 100)) this.moveXSpeed *= -1;
                if (this.y < 0 || this.y > 100 - (this.size / window.innerHeight * 100)) this.moveYSpeed *= -1;

                // Keep within bounds
                this.x = Math.max(0, Math.min(100 - (this.size / window.innerWidth * 100), this.x));
                this.y = Math.max(0, Math.min(100 - (this.size / window.innerHeight * 100), this.y));
            }
        }


        // --- Social Button Class ---
        class SocialButton {
            constructor(x, y, size, moveXSpeed, moveYSpeed, href, imgSrc, imgAlt) {
                this.x = x; //vw
                this.y = y; //vh
                this.size = size; //px
                this.moveXSpeed = moveXSpeed;
                this.moveYSpeed = moveYSpeed;
                this.href = href;
                this.element = document.createElement('a');
                this.element.classList.add('social-button');
                this.element.href = href;
                this.element.target = '_blank';
                this.element.rel = "noopener noreferrer";

                const img = document.createElement('img');
                img.src = imgSrc;
                img.alt = imgAlt;
                this.element.appendChild(img);

                this.element.style.width = `${this.size}px`;
                this.element.style.height = `${this.size}px`;

                this.updatePosition();
                animationContainer.appendChild(this.element);
            }

            updatePosition() {
                this.element.style.left = `${this.x}vw`;
                this.element.style.top = `${this.y}vh`;
            }

            update() {
                this.handleBoundaryCollisions();
                this.x += this.moveXSpeed;
                this.y += this.moveYSpeed;
                this.updatePosition();
            }

            handleBoundaryCollisions() {
                if (this.x < 0 || this.x > 100 - (this.size / window.innerWidth * 100)) {
                    this.moveXSpeed = -this.moveXSpeed + random(-0.2, 0.2); // Add some randomness
                }
                if (this.y < 0 || this.y > 100 - (this.size / window.innerHeight * 100)) {
                    this.moveYSpeed = -this.moveYSpeed + random(-0.2, 0.2); // Add some randomness
                }
                // Keep within bounds
                this.x = Math.max(0, Math.min(100 - (this.size / window.innerWidth * 100), this.x));
                this.y = Math.max(0, Math.min(100 - (this.size / window.innerHeight * 100), this.y));
            }
        }


        // --- Helper Functions ---

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }


        // --- Grid-based Spatial Partitioning ---

        function clearGrid() {
            grid = {};
        }

        function addToGrid(item) { // Works for circles and buttons
            const gridX = Math.floor((item.x / 100 * window.innerWidth) / GRID_CELL_SIZE);
            const gridY = Math.floor((item.y / 100 * window.innerHeight) / GRID_CELL_SIZE);
            item.gridX = gridX; //for the circle
            item.gridY = gridY; //for the circle

            if (!grid[gridX]) {
                grid[gridX] = {};
            }
            if (!grid[gridX][gridY]) {
                grid[gridX][gridY] = [];
            }
            grid[gridX][gridY].push(item);
        }


        function getNeighbors(item) {
            const gridX = item.gridX;
            const gridY = item.gridY;
            const neighbors = [];

            for (let x = Math.max(0, gridX - 1); x <= gridX + 1; x++) {
                for (let y = Math.max(0, gridY - 1); y <= gridY + 1; y++) {
                    if (grid[x] && grid[x][y]) {
                        neighbors.push(...grid[x][y]);
                    }
                }
            }
            return neighbors;
        }

        // --- Animation Control ---

        function chooseReactiveCircles() {
            for (const circle of circles) {
                circle.isReactive = false;
            }
            const numReactive = Math.floor(NUM_CIRCLES * REACTIVE_PERCENTAGE);
            for (let i = 0; i < numReactive; i++) {
                const randomIndex = Math.floor(Math.random() * circles.length);
                if (!circles[randomIndex].isReactive) {
                    circles[randomIndex].isReactive = true;
                    circles[randomIndex].reactiveUntil = Date.now() + REACTIVE_DURATION;
                }
            }
        }


        function startAnimation() {
            if (animationRunning) return;
            animationRunning = true;
            controlButton.textContent = 'Stop Animation';

            for (const circle of circles) {
                 animationFrameId = requestAnimationFrame(() => circle.update(mouseX, mouseY));
            }
            animationFrameId = requestAnimationFrame(() => linkedinButton.update()); // Update method for buttons
            animationFrameId = requestAnimationFrame(() => githubButton.update()); // Update method for buttons
            intervalId = setInterval(chooseReactiveCircles, REACTIVE_DURATION);
        }

        function stopAnimation() {
            if (!animationRunning) return;
            animationRunning = false;
            controlButton.textContent = 'Start Animation';
            cancelAnimationFrame(animationFrameId);
            clearInterval(intervalId);
        }
        // --- Main Animation Loop ---

        function animateCircles() {
            if (!window.innerWidth || !window.innerHeight) return;

            animationContainer.innerHTML = '';
            circles = [];
            clearGrid(); // Clear the grid

            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const smallerDimension = Math.min(viewportWidth, viewportHeight);
            const minCircleSize = smallerDimension * MIN_SIZE_PERCENTAGE;
            const maxCircleSize = smallerDimension * MAX_SIZE_PERCENTAGE;
            const adjustedMinCircleSize = Math.max(minCircleSize, ABSOLUTE_MIN_SIZE);

            // Create Circles
            for (let i = 0; i < NUM_CIRCLES; i++) {
                const size = random(adjustedMinCircleSize, maxCircleSize);
                const x = random(0, 100 - (size / window.innerWidth * 100));
                const y = random(0, 100 - (size / window.innerHeight * 100));
                const moveXSpeed = random(-ANIMATION_SPEED, ANIMATION_SPEED) * SPEED_RANDOMNESS_FACTOR;
                const moveYSpeed = random(-ANIMATION_SPEED, ANIMATION_SPEED) * SPEED_RANDOMNESS_FACTOR;
                const hue = random(180, 240);
                const circle = new Circle(x, y, size, moveXSpeed, moveYSpeed, hue);
                circles.push(circle);
                addToGrid(circle); // Add to grid
                animationFrameId = requestAnimationFrame(() => circle.update(mouseX, mouseY));

            }


            // Create LinkedIn Button
            if (!linkedinButton) {
                const x = random(0, 100 - (SOCIAL_BUTTON_SIZE / window.innerWidth * 100));
                const y = random(0, 100 - (SOCIAL_BUTTON_SIZE / window.innerHeight * 100));
                linkedinButton = new SocialButton(
                    x,
                    y,
                    SOCIAL_BUTTON_SIZE,
                    random(-1,1) * BUTTON_SPEED, // Random initial direction
                    random(-1,1) * BUTTON_SPEED, // Random initial direction
                    'https://www.linkedin.com/in/jozsefkecskesi/',
                    "img/linkedin.png", // Make sure this image exists
                    "LinkedIn"
                );
                addToGrid(linkedinButton); // Add to grid
            }

            // Create GitHub Button
            if (!githubButton) {
                const x = random(0, 100 - (SOCIAL_BUTTON_SIZE / window.innerWidth * 100));
                const y = random(0, 100 - (SOCIAL_BUTTON_SIZE / window.innerHeight * 100));
                githubButton = new SocialButton(
                    x,
                    y,
                    SOCIAL_BUTTON_SIZE,
                    random(-1,1) * BUTTON_SPEED, // Random initial direction
                    random(-1,1) * BUTTON_SPEED, // Random initial direction
                    'https://github.com/jozsefKecskesi', // Replace with your GitHub URL
                    "img/github.png",       // Make sure this image exists!
                    "GitHub"
                );
                 addToGrid(githubButton); // Add to grid
            }


            chooseReactiveCircles();
            if(animationRunning) intervalId = setInterval(chooseReactiveCircles, REACTIVE_DURATION); //only if runnning
            animationFrameId = requestAnimationFrame(() => linkedinButton.update());
            animationFrameId = requestAnimationFrame(() => githubButton.update());
        }

        // --- Event Listeners ---

        controlButton.addEventListener('click', () => {
            if (animationRunning) {
                stopAnimation();
            } else {
                startAnimation();
            }
        });

        document.addEventListener('mousemove', (event) => {
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mouseleave', () => {
            mouseX = -MOUSE_INFLUENCE_RADIUS * 2;
            mouseY = -MOUSE_INFLUENCE_RADIUS * 2;
        });

        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (animationRunning) {
                    stopAnimation();
                    animateCircles();
                }
            }, RESIZE_DEBOUNCE_TIME);
        });

        // --- Initialization ---
        animateCircles();
    </script>
</body>
</html>